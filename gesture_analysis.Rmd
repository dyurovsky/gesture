---
title: Speech/gesture tradeoffs in natural interactions
author: Dan Yurovsky, Maddie Meyers, Nicole Burke, Susan Goldin-Meadow, and Amanda Woodward
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: false
    number_sections: false
    theme: lumen
    toc_float: false
    code_folding: hide
---

```{r setup, include = FALSE}
# load packages
library(knitr)
library(tidyverse)
library(langcog)
library(stringr) 
library(lme4)
library(directlabels)
library(DT)
library(broom)
library(data.table)
library(ggplot2)

opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, 
               error = FALSE, cache = TRUE, tidy = FALSE)

theme_dy <- function(base_size = 14) 
{
  theme_bw() +   
  ggplot2::`%+replace%`(ggplot2::theme_bw(base_size = base_size),
                          ggplot2::theme(panel.grid = ggplot2::element_blank(), 
        legend.position = "none"))
}

theme_set(theme_dy())
```

## R Markdown

Load in coded data and show how many children we have at each age
```{r load_data}
files <-list.files("ldp_data/fixed_data/", 
                   "*.csv", full.names = TRUE)

loaded_subjs <- map(files, fread, sep=",", na.strings = c("NA", "")) %>%
  bind_rows() %>%
  mutate(age = 10+session*4) %>%
  group_by(subj, age) %>%
  mutate(time = 1:n()) %>%
  select(time, subj, age, person, spoken_obj, gestured_obj, referent, gloss, chat) 

demos <- loaded_subjs %>%
  select(subj,age) %>%
  distinct(subj,age, .keep_all = TRUE) %>%
  group_by(age) %>%
  summarise(n = n())

  
datatable(demos, rownames = FALSE, options = list(searching = FALSE), width = 300)
```

Let's look at the referents first

```{r referent_freqs}
# Compute the frequency of each distinct referent
referents <- loaded_subjs %>%
  ungroup() %>%
  select(referent) %>%
  filter(!is.na(referent)) %>%
  map(~str_split(string = ., pattern = ";")) %>% #split multiple-referents
  unlist() %>%
  map(str_trim) %>% # trim white space
  unlist() %>%
  data_frame(referent = .) %>%
  group_by(referent) %>%
  summarise(freq = n()) %>%
  arrange(desc(freq)) %>%
  mutate(rank = 1:nrow(.)) %>%
  select(rank,referent, freq)

referent_names <- datatable(referents, rownames = FALSE, width = 600)
referent_names

#sort referents alphabetically to try to find mistakes in data 
abc_referents <- referents[order(referents$referent),]
datatable(abc_referents, caption="Alphabetical List of Referents", 
          rownames = FALSE, width = 600)

```

Plot referent frequences in normal and log-log scale
```{r ref_plots, fig.width = 5, fig.height = 2.5}
ggplot(referents, aes(x = rank, y = freq, group = 1)) + 
  geom_point(size = .5) +
  xlab("Rank Frequency") +
  ylab("Frequency")


ggplot(referents, aes(x = rank, y = freq, group = 1)) + 
  geom_point(size = .5, color = "darkred") +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  scale_y_log10(name = "Log Frequency") +
  scale_x_log10(name = "Log Rank Frequency") + 
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
```

```{r childes_comparison, include=FALSE, eval= FALSE}
childes_freqs <- fread("ldp_data/coded_data/parentfreq.txt", sep = " ") %>%
  rename(freq = V1, word = V2) %>%
  mutate(rank = 1:nrow(.))


ggplot(childes_freqs, aes(x = rank, y = freq, group = 1)) + 
  geom_point(size = .5, color = "darkred") +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  scale_y_log10(name = "Log Frequency") +
  scale_x_log10(name = "Log Rank Frequency") + 
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
```

It looks like our referent frequency distribution is not actually well described by Zipf's law (yet?). There aren't enough low frequency referents in the tail. Let's try with just words:

Plot referent frequences in normal and log-log scale

```{r spoken_ref_plots, fig.width = 5, fig.height = 2.5}
ggplot(spoken_referents, aes(x = rank, y = freq, group = 1)) + 
  geom_point(size = .5) +
  xlab("Rank Frequency") +
  ylab("Frequency") +
  theme()


ggplot(spoken_referents, aes(x = rank, y = freq, group = 1)) + 
  geom_point(size = .5, color = "darkred") +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  scale_y_log10(name = "Log Frequency") +
  scale_x_log10(name = "Log Rank Frequency") + 
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
```

Looks similar... Maybe things will look a bit better with more data coded? Interesting to think about why this isn't Zipfian. Maybe we should think about discourse topics?

Ok, let's try the main analysis: Does frequency predict speech/gesture?

```{r speech_gesture_freq}
max_refs <- loaded_subjs %>%
  ungroup() %>%
  gather(ref_col, refs, spoken_obj, gestured_obj, referent) %>%
  mutate(num_refs = str_count(refs,";")) %>%
  summarise(num_refs = max(num_refs, na.rm = T)+1) %>%
  as.integer()
  
ref_list <- sapply(1:max_refs,function(x) paste0("referent",x))

spread_referents <- loaded_subjs %>%
  separate_("referent", ref_list, sep = ";", fill = "right") %>%
  gather_("number", "referent", ref_list) %>%
  filter(!is.na(referent)) %>%
  mutate(referent = str_trim(referent))

coded_responses <- spread_referents %>%
  mutate(spoken_obj = map(str_split(spoken_obj, ";"), str_trim),
         gestured_obj = map(str_split(gestured_obj, ";"), str_trim)) %>%
  rowwise() %>%
  mutate(spoken = purrr::contains(spoken_obj[[1]], referent),
         gestured = purrr::contains(gestured_obj[[1]], referent),
         both = spoken & gestured) %>%
  ungroup() %>%
  mutate(modality = if_else(spoken & gestured, "both", 
                            if_else(spoken, "speech", "gesture"))) %>%
  select(time, subj, age, person, referent, modality, chat, gloss) %>%
  left_join(referents) %>%
  mutate(freq_cut = cut(log(freq), 4))

modality_data <- coded_responses %>%
  group_by(person, age, subj, freq_cut, rank, freq, referent, modality, chat) %>%
  summarise(n = n()) %>%
  spread(modality, n, fill = 0)
```

Does parent/child production of reference in *both* modalities simultaneously changes with age and word frequency?

```{r both_probabilities}
both_data <- modality_data %>%
  group_by(person, age, freq_cut) %>%
  summarise(both = sum(both), gesture = sum(gesture), speech = sum(speech)) %>%
  gather(modality, count, both, gesture, speech) %>%
  group_by(person, freq_cut, age) %>%
  mutate(count = count/sum(count)) %>%
  group_by(person, freq_cut, modality) %>%
  summarise(count = mean(count))

ggplot(aes(x = freq_cut, y = count, color = modality, group = modality), 
       data = both_data) + 
  facet_wrap(~ person) + 
  geom_point() + 
  theme(legend.position = "right") + 
  geom_smooth(se = FALSE)
```


Try making Frank et al. style Gleitman plots. It turns out we have too many different referents... Here are a few ways of collapsing the data to get a better sense for it
```{r gleitman_plots}
gleitman_data <- coded_responses %>%
  #filter(subj == 29, age == 22) %>%
  filter(subj==29) %>%
  mutate(order = as.numeric(as.factor(time))) %>%
  filter(order > 100, order < 300, freq>200) 
  

ref_freqs <- gleitman_data %>%
  group_by(referent) %>%
  summarise(n = n()) %>%
  arrange(n)

gleitman_sorted <- gleitman_data %>%
  mutate(referent = factor(referent, levels = ref_freqs$referent))
  
#plot of all the referent mentions with parent and child different modalities, sorted by frequency of referent for a specific subset  
ggplot(aes(x = order, y = referent, fill = interaction(person, modality)),
           data = gleitman_sorted) + 
  geom_tile(color = "black") +
  theme(legend.position = "bottom") +facet_wrap (~age)


discourse_data <- coded_responses %>%
  mutate(order = as.numeric(as.factor(time))) %>%
  filter(referent != "mom") %>%
  filter(subj==29, age==22) %>%
  filter(order > 25, order < 95) %>%
  mutate(new_discourse = lag(referent) == referent)%>%
  group_by(person,new_discourse, order, modality) %>%
  summarize(count=n()) %>%
  mutate(proportion=count/sum(count)) 

#plot showing tradeoff of discourse (need to choose individual subject, too much to look at overall)
ggplot(aes(x = order, y = person, fill = new_discourse), data = discourse_data) + 
  geom_tile(color = "black") +
  theme(legend.position = "bottom")+facet_wrap( ~ modality)


```
```{r "first" referent}
#here, we want to see what modality the parent or child is most likely to use to mention a new referent where new=different from the last one 

discourse_child_data <- coded_responses %>%
  mutate(order = as.numeric(as.factor(time))) %>%
  filter(referent != "mom") %>%
  mutate(new_discourse = lag(referent) == referent)%>%
  filter(person=="child") %>%
  group_by(age, new_discourse, modality) %>%
  summarize(count=n()) %>%
  mutate(proportion=count/sum(count)) 

discourse_parent_data <- coded_responses %>%
  mutate(order = as.numeric(as.factor(time))) %>%
  filter(referent != "mom") %>%
  mutate(new_discourse = lag(referent) == referent)%>%
  filter(person=="parent") %>%
  group_by(age, new_discourse, modality) %>%
  summarize(count=n()) %>%
  mutate(proportion=count/sum(count)) 

#plot of porportion based on modality and whether it was a new referent or not with age
#child
ggplot(aes(x = modality, y=proportion, fill = new_discourse),
           data = discourse_child_data ) + 
  geom_bar(position="dodge", stat="identity")+ 
  theme(legend.position = "bottom") + facet_wrap (~ age)  

#parent (what is the weird NA?)
ggplot(aes(x = modality, y=proportion, fill = new_discourse),
           data = discourse_parent_data ) + 
  geom_bar(position="dodge", stat="identity")+ 
  theme(legend.position = "bottom") + facet_wrap (~ age) 

#plot of everything on one (harder to see)
ggplot(discourse_child_data, aes(x = modality, y = proportion, color=new_discourse)) + 
  facet_wrap(~ age) + 
  geom_point()+geom_point(data=discourse_parent_data, size=3)+theme(legend.position="bottom")
```

```{r first referent}
#we want to see the probability of modality/person referencing something for the first time, not just if it is the same or different from the last referent 

first_data <- coded_responses %>%
  group_by(subj, age, referent) %>%
  slice(1) %>% #take first time it is referenced within the session
  group_by(subj, age, person, modality) %>%
  summarise(n = n()) %>%
  group_by(age, subj, person) %>%
  mutate(n = n/sum(n)) %>% #probability
  group_by(age, person, modality) %>%
  summarise(n = mean(n))

#take out first 
not_first_data <- coded_responses %>%
  group_by(subj, age, referent) %>%
  slice(2:nrow(.)) %>% #take first time it is referenced within the session
  group_by(subj, age, person, modality) %>%
  summarise(n = n()) %>%
  group_by(age, subj, person) %>%
  mutate(n = n/sum(n)) %>% #probability
  group_by(age, person, modality) %>%
  summarise(n = mean(n))

#from this plot, we can see that for the children < 26mos, they are more likely to gesture to an object if it is the first utterance, and they are also more likely to both gesutre/speech to the object if it is the first utternace. THeya re less likely to use speech as the first reference. Are these relationships significant?
ggplot(first_data, aes(x = age, y = n, color = modality)) + 
  facet_wrap(~ person) + 
  geom_point()+geom_point(data=not_first_data, size=3)

```

```{r transition matrix- WORK IN PROGRESS}
#make probability matrix of transitions between parent speech, child speech, parent gesture, child gesture, parent both, child both (AKA transition matrix of interaction between person and modality) 

#use order variable to show what modality it was at at each moment, and who was speaking at each moment
#first want to set up matrix with the data the way we want it (order with/by person and modality)
#next want to calculate the probability of transitioning from one person and one modality to the next and put that into a matrix 

transition_responses<-coded_responses %>%
  select(subj, age, person, time, referent, modality) %>%
  filter(modality != "both") %>%
  group_by(subj, age) %>%
  mutate(same_person = person == lag(person), 
         same_modality = modality == lag(modality), 
         same_referent = referent == lag(referent)) %>%
  group_by(age, person, modality, subj) %>%
  #summarise_at(vars(same_person, same_modality, same_referent), funs(mean), na.rm = T) %>%
  summarise_at(vars(same_person, same_modality, same_referent), funs(mean), na.rm = T) %>%
  gather(measure, value, same_person, same_modality, same_referent) %>%
  group_by(age, person, modality, measure) %>%
  summarise_at(vars(value), funs(mean, sem))


ggplot(transition_responses, aes(x = age, y = mean, color = person,
                                 label = person)) + 
  facet_grid(measure ~ modality) + 
  geom_pointrange(aes(ymin = mean - sem, ymax = mean + sem), 
                  position = position_dodge(.5)) + 
  geom_line() + 
  geom_dl(method = list(dl.trans(x=x +.2), "last.qp", cex=1)) +
  scale_x_continuous(limits = c(13, 30))


same_ref_transitions<-coded_responses %>%
  select(subj, age, person, time, referent, modality) %>%
  group_by(subj, age) %>%
  mutate(same_person = person == lag(person), 
         same_modality = modality == lag(modality), 
         same_referent = referent == lag(referent)) %>%
  filter(same_referent) %>%
  group_by(age, person, modality, subj) %>%
  #summarise_at(vars(same_person, same_modality, same_referent), funs(mean), na.rm = T) %>%
  summarise_at(vars(same_person, same_modality), funs(mean), na.rm = T) %>%
  gather(measure, value, same_person, same_modality) %>%
  group_by(age, person, modality, measure) %>%
  summarise_at(vars(value), funs(mean, sem))

consecutive_gestures <- coded_responses %>%
  select(subj, age, person, time, referent, modality, gloss, chat) %>%
  mutate(same_person = person == lead(person), 
         lead_modality = lead(modality), 
         same_referent = referent == lead(referent)) %>%
  filter(person == "child", same_person, lead_modality == "gesture")

  
  
ggplot(same_ref_transitions, aes(x = age, y = mean, color = person,
                                 label = person)) + 
  facet_grid(measure ~ modality) + 
  geom_pointrange(aes(ymin = mean - sem, ymax = mean + sem), 
                  position = position_dodge(.5)) + 
  geom_line() + 
  geom_dl(method = list(dl.trans(x=x +.2), "last.qp", cex=1)) +
  scale_x_continuous(limits = c(13, 30))



 # mutate(same_ref=lag(referent)==referent,
         #same_mod=lag(modality)==modality,
         #same_person=lag(person)==person,
         #same_mod_same_ref=(lag(modality)==modality & lag(referent)==referent),
         #same_mod_same_per=(lag(modality)==modality & lag(person)==person),
         #same_everything=(lag(modality)==modality & lag(person)==person   &lag(referent)==referent))

#start by doing a matrix where at each time/state, you have whether it was a parent or child speaking
#start with separate person and modality data frames
#then run the data frame 
#eventually account for the times where it is independent transitions (ex. between children)
#as.matrix, change row to col 
dat<-data.frame(replicate(20,sample(c("A", "B", "C","D"), size = 100, replace=TRUE)))

trans.matrix <- function(X, prob=T)
{
    tt <- table( c(X[-nrow(X),]), c(X[-1,]) )
    if(prob) tt <- tt / colSums(tt)
    tt
}
trans.matrix()
```

```{r speech_gesture_plot, fig.width = 9, fig.height = 4}
plotting_data <- coded_responses %>%
  filter(modality != "both") %>%
  group_by(person, age, subj, freq_cut, modality) %>%
  summarise(n = n()) %>%
  mutate(prob = n/sum(n)) %>%
  group_by(person, age, modality, freq_cut) %>%
  multi_boot_standard("prob")

ggplot(plotting_data, aes(x = as.numeric(freq_cut), y = mean, color = modality,
                          label = modality)) +
  facet_grid(person ~ age) + 
  geom_pointrange(aes(ymax = ci_upper, ymin = ci_lower), 
                  position = position_dodge(.25)) + 
  scale_color_brewer(palette = "Set1") +
  geom_dl(method = list(dl.trans(x=x +.2), "last.qp", cex=1)) +
  scale_x_continuous(limits = c(.5, 5.7),
                     breaks = seq(1, 4),
                     name = "Frequency Quartile") +
  ylab("Production Probability")
```

Now lets fit some statistical models to this to see if the effects are robust

```{r fit_models}
tidy_table <- function(mermod) {
  tidy(mermod) %>%
    filter(group == "fixed") %>%
    select(-group)
}

child_lm <- glmer(cbind(speech, gesture) ~ age * log(freq) + 
                    (1|referent) + (1|subj), 
      data = filter(modality_data, person == "child"),
      family = "binomial")

datatable(tidy_table(child_lm), rownames = FALSE, 
          options = list(searching = FALSE), width = 400)

parent_lm <- glmer(cbind(speech, gesture) ~ age + log(freq) + 
                    (1|referent) + (1|subj), 
      data = filter(modality_data, person == "parent"),
      family = "binomial")

datatable(tidy_table(parent_lm), rownames = FALSE, 
          options = list(searching = FALSE), width = 400)
```

Let's also check whether production of *both* modalities simultaneously changes over development and frequency

```{r both_model}

child_both_lm <- glmer(cbind(both, speech + gesture) ~ age * log(freq) + 
                    (1|referent) + (1|subj), 
      data = filter(modality_data, person == "child"),
      family = "binomial")

datatable(tidy_table(child_both_lm), rownames = FALSE, 
          options = list(searching = FALSE), width = 400)

parent_both_lm <- glmer(cbind(both, speech + gesture) ~ age + log(freq) + 
                    (1|referent) + (1|subj), 
      data = filter(modality_data, person == "parent"),
      family = "binomial")

datatable(tidy_table(parent_both_lm), rownames = FALSE, 
          options = list(searching = FALSE), width = 400)

```
