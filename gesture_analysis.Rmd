---
title: Speech/gesture tradeoffs in natural interactions
author: Dan Yurovsky, Maddie Meyers, Nicole Burke, Susan Goldin-Meadow, and Amanda Woodward
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: false
    number_sections: false
    theme: lumen
    toc_float: false
    code_folding: hide
---

```{r setup, include = FALSE}
# load packages
library(knitr)
library(tidyverse)
library(langcog)
library(stringr) 
library(lme4)
library(directlabels)
library(DT)
library(broom)
library(data.table)
library(ggplot2)
library(forcats)
library(feather)
library(dplyr)

opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, 
               error = FALSE, cache = TRUE, tidy = FALSE)

theme_dy <- function(base_size = 14) 
{
  theme_bw() +   
  ggplot2::`%+replace%`(ggplot2::theme_bw(base_size = base_size),
                          ggplot2::theme(panel.grid = ggplot2::element_blank(), 
        legend.position = "none"))
}

theme_set(theme_dy())
```

## R Markdown

Load in coded data and show how many children we have at each age
```{r load_data}
#load in original data
loaded_subjs <- read_feather('feathers/loaded_subjs.feather')
#referent data 
referents<-read_feather('feathers/referents.feather')
#coded responses
coded_responses<-read_feather('feathers/coded_responses.feather')

demos <- loaded_subjs %>%
  select(subj,age) %>%
  distinct(subj,age, .keep_all = TRUE) %>%
  group_by(age) %>%
  summarise(n = n())

  
datatable(demos, rownames = FALSE, options = list(searching = FALSE), width = 300)
```

Let's look at the referents first

```{r referent_freqs}
# Compute the frequency of each distinct referent
referents <- loaded_subjs %>%
  ungroup() %>%
  select(referent) %>%
  filter(!is.na(referent)) %>%
  map(~str_split(string = ., pattern = ";")) %>% #split multiple-referents
  unlist() %>%
  map(str_trim) %>% # trim white space
  unlist() %>%
  data_frame(referent = .) %>%
  group_by(referent) %>%
  summarise(freq = n()) %>%
  arrange(desc(freq)) %>%
  mutate(rank = 1:nrow(.)) %>%
  select(rank,referent, freq)

write_feather(referents, 'feathers/referents.feather')

referent_names <- datatable(referents, rownames = FALSE, width = 600)
referent_names
```

Plot referent frequences in normal and log-log scale
```{r ref_plots, fig.width = 5, fig.height = 2.5}
ggplot(referents, aes(x = rank, y = freq, group = 1)) + 
  geom_point(size = .5) +
  xlab("Rank Frequency") +
  ylab("Frequency")


ggplot(referents, aes(x = rank, y = freq, group = 1)) + 
  geom_point(size = .5, color = "darkred") +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  scale_y_log10(name = "Log Frequency") +
  scale_x_log10(name = "Log Rank Frequency") + 
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
```

```{r childes_comparison, include=FALSE, eval= FALSE}
childes_freqs <- fread("ldp_data/coded_data/parentfreq.txt", sep = " ") %>%
  rename(freq = V1, word = V2) %>%
  mutate(rank = 1:nrow(.))


ggplot(childes_freqs, aes(x = rank, y = freq, group = 1)) + 
  geom_point(size = .5, color = "darkred") +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  scale_y_log10(name = "Log Frequency") +
  scale_x_log10(name = "Log Rank Frequency") + 
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
```

It looks like our referent frequency distribution is not actually well described by Zipf's law (yet?). There aren't enough low frequency referents in the tail. Let's try with just words:

Plot referent frequences in normal and log-log scale

```{r spoken_ref_plots, fig.width = 5, fig.height = 2.5}
spoken_referents <- loaded_subjs %>%
  ungroup() %>%
  select(spoken_obj) %>%
  filter(!is.na(spoken_obj)) %>%
  map(~str_split(string = ., pattern = ";")) %>% #split multiple-referents
  unlist() %>%
  map(str_trim) %>% # trim white space
  unlist() %>%
  data_frame(referent = .) %>%
  group_by(referent) %>%
  summarise(freq = n()) %>%
  arrange(desc(freq)) %>%
  mutate(rank = 1:nrow(.)) %>%
  select(rank,referent, freq)

ggplot(spoken_referents, aes(x = rank, y = freq, group = 1)) + 
  geom_point(size = .5) +
  xlab("Rank Frequency") +
  ylab("Frequency") +
  theme()


ggplot(spoken_referents, aes(x = rank, y = freq, group = 1)) + 
  geom_point(size = .5, color = "darkred") +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  scale_y_log10(name = "Log Frequency") +
  scale_x_log10(name = "Log Rank Frequency") + 
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
```

Looks similar... Maybe things will look a bit better with more data coded? Interesting to think about why this isn't Zipfian. Maybe we should think about discourse topics?

Ok, let's try the main analysis: Does frequency predict speech/gesture?

```{r speech_gesture_freq}
max_refs <- loaded_subjs %>%
  ungroup() %>%
  gather(ref_col, refs, spoken_obj, gestured_obj, referent) %>%
  mutate(num_refs = str_count(refs,";")) %>%
  summarise(num_refs = max(num_refs, na.rm = T)+1) %>%
  as.integer()
  
ref_list <- sapply(1:max_refs,function(x) paste0("referent",x))

spread_referents <- loaded_subjs %>%
  separate_("referent", ref_list, sep = ";", fill = "right") %>%
  gather_("number", "referent", ref_list) %>%
  filter(!is.na(referent)) %>%
  mutate(referent = str_trim(referent))

coded_responses <- spread_referents %>%
  mutate(spoken_obj = map(str_split(spoken_obj, ";"), str_trim),
         gestured_obj = map(str_split(gestured_obj, ";"), str_trim)) %>%
  rowwise() %>%
  mutate(spoken = purrr::has_element(spoken_obj[[1]], referent),
         gestured = purrr::has_element(gestured_obj[[1]], referent),
         both = spoken & gestured) %>%
  ungroup() %>%
  mutate(modality = if_else(spoken & gestured, "both", 
                            if_else(spoken, "speech", "gesture"))) %>%
  select(time, time2, subj, age, person, referent, modality, chat, gloss) %>%
  left_join(referents) %>%
  mutate(freq_cut = cut(log(freq), 4))

write_feather(coded_responses, 'feathers/coded_responses.feather')

modality_data <- coded_responses %>%
  group_by(person, age, subj, freq_cut, rank, freq, referent, modality, chat) %>%
  summarise(n = n()) %>%
  spread(modality, n, fill = 0)
```

These plots show the tradeoff between speech and gesture across ages for children and parents. 
```{r speech_gesture_plot, fig.width=9, fig.height=4}
plotting_data <- coded_responses %>%
  group_by(person, age, subj, freq_cut, modality) %>%
  summarise(n = n()) %>%
  mutate(prob = n/sum(n)) %>%
  group_by(person, age, modality, freq_cut) %>%
  multi_boot_standard("prob")

ggplot(plotting_data, aes(x = as.numeric(freq_cut), y = mean, color = modality,
                          label = modality)) +
  facet_grid(person ~ age) + 
  geom_pointrange(aes(ymax = ci_upper, ymin = ci_lower), 
                  position = position_dodge(.25)) + 
  scale_color_brewer(palette = "Set1") +
  geom_dl(method = list(dl.trans(x=x +.2), "last.qp", cex=1)) +
  scale_x_continuous(limits = c(.5, 5.7),
                     breaks = seq(1, 4),
                     name = "Frequency Quartile") +
  ylab("Production Probability")
```

Now lets fit some statistical models to this to see if the effects are robust

```{r fit_models}
tidy_table <- function(mermod) {
  tidy(mermod) %>%
    filter(group == "fixed") %>%
    select(-group)
}

child_lm <- glmer(cbind(speech, gesture) ~ age * log(freq) + 
                    (1|referent) + (1|subj), 
      data = filter(modality_data, person == "child"),
      family = "binomial")

datatable(tidy_table(child_lm), rownames = FALSE, 
          options = list(searching = FALSE), width = 400)

parent_lm <- glmer(cbind(speech, gesture) ~ age + log(freq) + 
                    (1|referent) + (1|subj), 
      data = filter(modality_data, person == "parent"),
      family = "binomial")

datatable(tidy_table(parent_lm), rownames = FALSE, 
          options = list(searching = FALSE), width = 400)
```

```{r first referent- FIX MULTI BOOT STANDARD ERROR}
#we want to see the probability of modality/person referencing something for the first time, not just if it is the same or different from the last referent 

usage_data <- bind_rows(first_data, not_first_data) %>%
  filter(freq>1) %>% 
  group_by(subj, age, person, modality, first) %>%
  summarise(n = n()) %>% 
  group_by(age, subj, person, first) %>%
  mutate(n = n/sum(n)) %>% #probability
  group_by(age, person, modality, first) %>%
  multi_boot_standard("n")  

#from this plot, we can see that for the children < 26mos, they are more likely to gesture to an object if it is the first utterance versus not first utterance, and they are also more likely to both gesutre/speech to the object if it is the first utternace. They are less likely to use speech as the first reference. The confidence intervals show that these relationships are significant
ggplot(usage_data, aes(x = age, y = mean, color = modality,
                       linetype = first)) + 
  facet_wrap(~ person) + 
  geom_pointrange(aes(ymin = ci_lower, ymax = ci_upper), 
                  size=.75, position = position_dodge(1),
                  show.legend = FALSE)+
  geom_line() +   
  theme(legend.position= "bottom") + 
  ylab("proportion of utterances") 


#now we are looking at frequency and seeing what happens for first or not first referents across the frequency for what modality and what person, see that parents over time increase speech (especially for first referents?)
usage_data_2 <- bind_rows(first_data, not_first_data) %>%
  filter(freq>1) %>% #taking out referents that are only mentioned once changes nothing
  group_by(subj, freq_cut, person, modality, first) %>%
  summarise(n = n()) %>%
  group_by(freq_cut, subj, person, first) %>%
  mutate(n = n/sum(n)) %>% #probability
  group_by(freq_cut, person, modality, first) %>%
  multi_boot_standard("n") #there is something wrong with this multi boot standard function 

ggplot(usage_data_2,
       aes(x = as.numeric(freq_cut), y = mean, 
           color = person, linetype = first)) + 
  facet_wrap(~ modality) +
  geom_pointrange(aes(ymin = ci_lower, ymax = ci_upper), 
                  size=.75, position = position_dodge(1),
                  show.legend = FALSE)+
  geom_line(position = position_dodge(1)) +   
  theme(legend.position= "bottom") + 
  ylab("proportion of utterances") 

```