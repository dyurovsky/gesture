---
title: Speech/gesture tradeoffs in natural interactions
author: Dan Yurovsky, Maddie Meyers, Nicole Burke, Susan Goldin-Meadow, and Amanda Woodward
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: false
    number_sections: false
    theme: lumen
    toc_float: false
    code_folding: hide
---

```{r setup, include = FALSE}
# load packages
library(knitr)
library(tidyverse)
library(langcog)
library(stringr) 
library(lme4)
library(directlabels)
library(DT)
library(broom)
library(data.table)
library(ggplot2)
library(forcats)

opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, 
               error = FALSE, cache = TRUE, tidy = FALSE)

theme_dy <- function(base_size = 14) 
{
  theme_bw() +   
  ggplot2::`%+replace%`(ggplot2::theme_bw(base_size = base_size),
                          ggplot2::theme(panel.grid = ggplot2::element_blank(), 
        legend.position = "none"))
}

theme_set(theme_dy())
```

## R Markdown

Load in coded data and show how many children we have at each age
```{r load_data}
files <-list.files("ldp_data/fixed_data/", 
                   "*.csv", full.names = TRUE)

loaded_subjs <- map(files, fread, sep=",", na.strings = c("NA", "")) %>%
  bind_rows() %>%
  mutate(age = 10+session*4) %>%
  mutate(time2=rownames(.)) %>%
  group_by(subj, age) %>%
  mutate(time = 1:n()) %>%
  select(time, time2, subj, age, person, spoken_obj, gestured_obj, referent, gloss, chat) 

demos <- loaded_subjs %>%
  select(subj,age) %>%
  distinct(subj,age, .keep_all = TRUE) %>%
  group_by(age) %>%
  summarise(n = n())

  
datatable(demos, rownames = FALSE, options = list(searching = FALSE), width = 300)
```

Let's look at the referents first

```{r referent_freqs}
# Compute the frequency of each distinct referent
referents <- loaded_subjs %>%
  ungroup() %>%
  select(referent) %>%
  filter(!is.na(referent)) %>%
  map(~str_split(string = ., pattern = ";")) %>% #split multiple-referents
  unlist() %>%
  map(str_trim) %>% # trim white space
  unlist() %>%
  data_frame(referent = .) %>%
  group_by(referent) %>%
  summarise(freq = n()) %>%
  arrange(desc(freq)) %>%
  mutate(rank = 1:nrow(.)) %>%
  select(rank,referent, freq)

referent_names <- datatable(referents, rownames = FALSE, width = 600)
referent_names

#sort referents alphabetically to try to find mistakes in data 
abc_referents <- referents[order(referents$referent),]
datatable(abc_referents, caption="Alphabetical List of Referents", 
          rownames = FALSE, width = 600)

```

Plot referent frequences in normal and log-log scale
```{r ref_plots, fig.width = 5, fig.height = 2.5}
ggplot(referents, aes(x = rank, y = freq, group = 1)) + 
  geom_point(size = .5) +
  xlab("Rank Frequency") +
  ylab("Frequency")


ggplot(referents, aes(x = rank, y = freq, group = 1)) + 
  geom_point(size = .5, color = "darkred") +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  scale_y_log10(name = "Log Frequency") +
  scale_x_log10(name = "Log Rank Frequency") + 
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
```

```{r childes_comparison, include=FALSE, eval= FALSE}
childes_freqs <- fread("ldp_data/coded_data/parentfreq.txt", sep = " ") %>%
  rename(freq = V1, word = V2) %>%
  mutate(rank = 1:nrow(.))


ggplot(childes_freqs, aes(x = rank, y = freq, group = 1)) + 
  geom_point(size = .5, color = "darkred") +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  scale_y_log10(name = "Log Frequency") +
  scale_x_log10(name = "Log Rank Frequency") + 
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
```

It looks like our referent frequency distribution is not actually well described by Zipf's law (yet?). There aren't enough low frequency referents in the tail. Let's try with just words:

Plot referent frequences in normal and log-log scale

```{r spoken_ref_plots, fig.width = 5, fig.height = 2.5}
spoken_referents <- loaded_subjs %>%
  ungroup() %>%
  select(spoken_obj) %>%
  filter(!is.na(spoken_obj)) %>%
  map(~str_split(string = ., pattern = ";")) %>% #split multiple-referents
  unlist() %>%
  map(str_trim) %>% # trim white space
  unlist() %>%
  data_frame(referent = .) %>%
  group_by(referent) %>%
  summarise(freq = n()) %>%
  arrange(desc(freq)) %>%
  mutate(rank = 1:nrow(.)) %>%
  select(rank,referent, freq)

ggplot(spoken_referents, aes(x = rank, y = freq, group = 1)) + 
  geom_point(size = .5) +
  xlab("Rank Frequency") +
  ylab("Frequency") +
  theme()


ggplot(spoken_referents, aes(x = rank, y = freq, group = 1)) + 
  geom_point(size = .5, color = "darkred") +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  scale_y_log10(name = "Log Frequency") +
  scale_x_log10(name = "Log Rank Frequency") + 
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
```

Looks similar... Maybe things will look a bit better with more data coded? Interesting to think about why this isn't Zipfian. Maybe we should think about discourse topics?

Ok, let's try the main analysis: Does frequency predict speech/gesture?

```{r speech_gesture_freq}
max_refs <- loaded_subjs %>%
  ungroup() %>%
  gather(ref_col, refs, spoken_obj, gestured_obj, referent) %>%
  mutate(num_refs = str_count(refs,";")) %>%
  summarise(num_refs = max(num_refs, na.rm = T)+1) %>%
  as.integer()
  
ref_list <- sapply(1:max_refs,function(x) paste0("referent",x))

spread_referents <- loaded_subjs %>%
  separate_("referent", ref_list, sep = ";", fill = "right") %>%
  gather_("number", "referent", ref_list) %>%
  filter(!is.na(referent)) %>%
  mutate(referent = str_trim(referent))

coded_responses <- spread_referents %>%
  mutate(spoken_obj = map(str_split(spoken_obj, ";"), str_trim),
         gestured_obj = map(str_split(gestured_obj, ";"), str_trim)) %>%
  rowwise() %>%
  mutate(spoken = purrr::has_element(spoken_obj[[1]], referent),
         gestured = purrr::has_element(gestured_obj[[1]], referent),
         both = spoken & gestured) %>%
  ungroup() %>%
  mutate(modality = if_else(spoken & gestured, "both", 
                            if_else(spoken, "speech", "gesture"))) %>%
  select(time, time2, subj, age, person, referent, modality, chat, gloss) %>%
  left_join(referents) %>%
  mutate(freq_cut = cut(log(freq), 4))

modality_data <- coded_responses %>%
  group_by(person, age, subj, freq_cut, rank, freq, referent, modality, chat) %>%
  summarise(n = n()) %>%
  spread(modality, n, fill = 0)
```

Does parent/child production of reference in *both* modalities simultaneously changes with age and word frequency?

```{r both_probabilities}
both_data <- modality_data %>%
  group_by(person, age, freq_cut) %>%
  summarise(both = sum(both), gesture = sum(gesture), speech = sum(speech)) %>%
  gather(modality, count, both, gesture, speech) %>%
  group_by(person, freq_cut, age) %>%
  mutate(count = count/sum(count)) %>%
  group_by(person, freq_cut, modality) %>%
  summarise(count = mean(count))

ggplot(aes(x = freq_cut, y = count, color = modality, group = modality), 
       data = both_data) + 
  facet_wrap(~ person) + 
  geom_point() + 
  theme(legend.position = "right") + 
  geom_smooth(se = FALSE)
```


```{r ref_density}
# Takes a data frame (grouped), a consecutive sample size (e.g. 10 rows), and a number of samples (e.g. 20 samples) and returns a sub-sampled dataframe with a new column "sample" that indicates the sample number

split_df <- function(df, size, count) {
 nrows <- df %>% 
   summarise(n = n()) %>% 
   ungroup() %>% 
   select(n) %>% 
   min
  
 num_splits <- floor(nrows / size)
 
 split_list <- map(1:num_splits, function(n) (n-1)*size + 1:size) %>%
   sample(., count)
 
 
 samples <- map(split_list, function(n) df %>% slice(n))
 
 sampled_df <- map(1:length(samples), 
                   function(n) mutate(samples[[n]], sample = n)) %>%
   bind_rows()
}

ref <- loaded_subjs %>%
  group_by(subj, age)

#need to split multiple referents in the sample data  
sample_ref <- split_df(ref, 16, 20) %>%
  mutate(spoken = (is.na(spoken_obj)==FALSE),
         gestured = (is.na(gestured_obj)==FALSE),
         both = spoken & gestured) %>%
  mutate(modality = if_else(both==TRUE, "both",  
                            if_else(spoken==TRUE, "speech", if_else(gestured==TRUE, "gesture", "")))) %>%
  select(time2, time, subj, age, sample, person, referent, modality, chat, gloss) 

#shows general (Gleitman) plot of one sample instance of discourse, just to see what it looks like 
sample3_ref<-sample_ref %>%
  filter(sample== 12)

ggplot(aes(x=time, y=referent, color=modality), data=sample3_ref) +geom_line()+facet_wrap(~age)+theme(legend.position="bottom")

#now want to see how many referents in the discourse are first referents and plot those averages 
first_data <- coded_responses %>%
  group_by(subj, age, referent) %>%
  slice(1) %>% 
  mutate(first = TRUE) 

not_first_data <- coded_responses %>%
  group_by(subj, age, referent) %>%
  slice(2:nrow(.)) %>% 
  mutate(first = FALSE)

first_ref <- sample_ref %>%
  mutate(isFirst = ifelse(time2 %in% first_data$time2, "first","not first")) %>%
  group_by(subj, age, sample, isFirst, person, modality) %>%
  summarise(count=sum(is.na(referent)==FALSE)) %>%
  group_by(isFirst, age, subj, person, modality) %>%
  summarise(avg_ref = sum(count) / (20))

ggplot(aes(x=age, y=(avg_ref/10), fill=isFirst), data=first_ref) + geom_bar(stat="identity")+ylab("average referents per discourse")+theme(legend.position="bottom")

#add in person data 
ggplot(first_ref, aes(x = age, y = (avg_ref/10), fill =  isFirst)) + 
  facet_wrap(~ person) +  
  geom_bar(stat="identity") +   
  theme(legend.position= "bottom") + 
  ylab("average referents per discourse") 

```

```{r "mom"}
#what we have here is a data set of all the times mom was referenced, with a variable saying what the referent was before this. We can use the time column to tell us if/how many times the referent "mom" was repeated by seeing how large the time steps are between references of mom 
#granted, this is somewhat flawed because there may be other references between mom--if they are trying to get attention, the mom may say a different referent in between, so let's try going two lags back
mom_repeated <-coded_responses %>%
  mutate(last_ref=lag(referent),
         last_last_ref=lag(last_ref)) %>%
  filter(person=="child") %>% #really only interested in how the child uses "mom", not as much how the mother refers to herself
  filter(referent=="mom")

mom_prop<-coded_responses %>%
  filter(person=="child") %>%
  group_by(subj, age) %>%
  summarise(prop= sum(as.integer(referent=="mom"))/sum(n()))

#when just looking at the plot of mom references across age for child, you see that there is a very sharp increase from 18 to 22 months--is this driving some of our other results? Is this difference significant? Ran a t-test and it was not significant (p=0.0885)
ggplot(aes(x=age, y=(prop/10)), data=mom_prop)+geom_bar(stat="identity")+ylab("Proportion of mom referents by child")
```

```{r Frank discourse}
#in the Frank et al discourse paper, they defined a discourse to be 3 or more continued references to the same referent. While this is a flawed definition of discourse, I was curious to see how many discourses were in our data set

discourse_amt<-coded_responses %>%
  mutate(lag_ref=lag(referent),
         lag_lag_ref=lag(lag_ref)) %>%
  filter(referent==lag_ref, lag_lag_ref == lag_ref) %>% #filter for strings of at least 3 same referent 
  group_by(subj, age, referent, time) %>%
  slice(1) %>% #don't count additional strings (flawed here because may have multiple strings of same word in same)? is this right coded here?
  group_by(subj, age) %>%
  summarise(disc_count= sum(n()))

#it seems like there are the most strings of at least 3 of same referent at age 22mos, not other months! interesting (not sure if coded completely right, definitely took some shortcuts)
ggplot(aes(x=age, y=(disc_count/10)), data=discourse_amt)+geom_bar(stat="identity")

#how do these data compare to Frank et al? They used only speech data with a much smaller sample of referents, 5-15 minute lengths of play (how long are ours?) with a total corpus of 5,000 utterances (smaller) and found 6mos=88 discourse, 12mos=110, 18mos=107. We would expect them to have more repeated discourses because they have many fewer potential referents. This seems to be the case, because even though we have more discourses, they may not have been coded correctly (overestimates) and the corpus is much, much larger 
discourse_2<-coded_responses %>%
  mutate(lag_ref=lag(referent),
         lag_lag_ref=lag(lag_ref)) %>%
  filter(referent==lag_ref, lag_lag_ref == lag_ref) %>% #filter for strings of at least 3 same referent 
  group_by(subj, age, referent, time) %>%
  slice(1) %>%
  filter(subj==33, age==22, time >500)

ggplot(aes(x = time, y = referent, fill =  interaction(person,modality)), data = discourse_2) + 
  geom_tile(color = "black") + 
  theme(legend.position = "bottom")
#finally, a gletiman plot that looks readable! 
```

```{r first referent- FIX MULTI BOOT STANDARD ERROR}
#we want to see the probability of modality/person referencing something for the first time, not just if it is the same or different from the last referent 

usage_data <- bind_rows(first_data, not_first_data) %>%
  filter(freq>1) %>% #taking out referents that are only mentioned once changes nothing
  group_by(subj, age, person, modality, first) %>%
  summarise(n = n()) %>% 
  group_by(age, subj, person, first) %>%
  mutate(n = n/sum(n)) %>% #probability
  group_by(age, person, modality, first) %>%
  multi_boot_standard("n")  

#from this plot, we can see that for the children < 26mos, they are more likely to gesture to an object if it is the first utterance versus not first utterance, and they are also more likely to both gesutre/speech to the object if it is the first utternace. They are less likely to use speech as the first reference. The confidence intervals show that these relationships are significant
ggplot(usage_data, aes(x = age, y = mean, color = modality,
                       linetype = first)) + 
  facet_wrap(~ person) + 
  geom_pointrange(aes(ymin = ci_lower, ymax = ci_upper), 
                  size=.75, position = position_dodge(1),
                  show.legend = FALSE)+
  geom_line() +   
  theme(legend.position= "bottom") + 
  ylab("proportion of utterances") 


#now we are looking at frequency and seeing what happens for first or not first referents across the frequency for what modality and what person, see that parents over time increase speech (especially for first referents?)
usage_data_2 <- bind_rows(first_data, not_first_data) %>%
  filter(freq>1) %>% #taking out referents that are only mentioned once changes nothing
  group_by(subj, freq_cut, person, modality, first) %>%
  summarise(n = n()) %>%
  group_by(freq_cut, subj, person, first) %>%
  mutate(n = n/sum(n)) %>% #probability
  group_by(freq_cut, person, modality, first) %>%
  multi_boot_standard("n") #there is something wrong with this multi boot standard function 

ggplot(usage_data_2,
       aes(x = as.numeric(freq_cut), y = mean, 
           color = person, linetype = first)) + 
  facet_wrap(~ modality) +
  geom_pointrange(aes(ymin = ci_lower, ymax = ci_upper), 
                  size=.75, position = position_dodge(1),
                  show.legend = FALSE)+
  geom_line(position = position_dodge(1)) +   
  theme(legend.position= "bottom") + 
  ylab("proportion of utterances") 

```

These plots show the tradeoff between speech and gesture across ages for children and parents. 
```{r speech_gesture_plot, fig.width=9, fig.height=4}
plotting_data <- coded_responses %>%
  #filter(modality != "both") %>%
  group_by(person, age, subj, freq_cut, modality) %>%
  summarise(n = n()) %>%
  mutate(prob = n/sum(n)) %>%
  group_by(person, age, modality, freq_cut) %>%
  multi_boot_standard("prob")

ggplot(plotting_data, aes(x = as.numeric(freq_cut), y = mean, color = modality,
                          label = modality)) +
  facet_grid(person ~ age) + 
  geom_pointrange(aes(ymax = ci_upper, ymin = ci_lower), 
                  position = position_dodge(.25)) + 
  scale_color_brewer(palette = "Set1") +
  geom_dl(method = list(dl.trans(x=x +.2), "last.qp", cex=1)) +
  scale_x_continuous(limits = c(.5, 5.7),
                     breaks = seq(1, 4),
                     name = "Frequency Quartile") +
  ylab("Production Probability")
```

Now lets fit some statistical models to this to see if the effects are robust

```{r fit_models}
tidy_table <- function(mermod) {
  tidy(mermod) %>%
    filter(group == "fixed") %>%
    select(-group)
}

child_lm <- glmer(cbind(speech, gesture) ~ age * log(freq) + 
                    (1|referent) + (1|subj), 
      data = filter(modality_data, person == "child"),
      family = "binomial")

datatable(tidy_table(child_lm), rownames = FALSE, 
          options = list(searching = FALSE), width = 400)

parent_lm <- glmer(cbind(speech, gesture) ~ age + log(freq) + 
                    (1|referent) + (1|subj), 
      data = filter(modality_data, person == "parent"),
      family = "binomial")

datatable(tidy_table(parent_lm), rownames = FALSE, 
          options = list(searching = FALSE), width = 400)
```

Let's also check whether production of *both* modalities simultaneously changes over development and frequency

```{r both_model}

child_both_lm <- glmer(cbind(both, speech + gesture) ~ age * log(freq) + 
                    (1|referent) + (1|subj), 
      data = filter(modality_data, person == "child"),
      family = "binomial")

datatable(tidy_table(child_both_lm), rownames = FALSE, 
          options = list(searching = FALSE), width = 400)

parent_both_lm <- glmer(cbind(both, speech + gesture) ~ age + log(freq) + 
                    (1|referent) + (1|subj), 
      data = filter(modality_data, person == "parent"),
      family = "binomial")

datatable(tidy_table(parent_both_lm), rownames = FALSE, 
          options = list(searching = FALSE), width = 400)

```
